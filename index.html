<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dice Poker Sequence</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        
        /* --- DARK THEME STYLES --- */
        
        /* Define Dark Theme Colors */
        :root {
            --primary-blue: #3B82F6;
            --primary-red: #DC2626;
            --primary-green: #10B981; /* New color for Player 3 */
            --highlight-green: #10B981; /* Highlight is same as Player 3 color, but used for claimable fields */
            --deep-dark: #111827;
            --dark-container: #1F2937;
            --medium-dark: #374151;
            --light-text: #D1D5DB;
            
            /* Custom Player Colors for Chips/Status text */
            --player-1-color: #3B82F6; /* Blue */
            --player-2-color: #DC2626; /* Red */
            --player-3-color: #10B981; /* Green */
        }

        body { 
            font-family: 'Inter', sans-serif; 
            background-color: var(--deep-dark); 
            color: var(--light-text); 
        }
        #game-container {
            background-color: var(--dark-container); 
            border: 2px solid #374151;
        }
        h1 {
            color: #F9FAFB;
            border-bottom-color: #4B5563;
            text-shadow: none;
        }
        
        /* Status Panel and Dice Area background */
        #status-panel, #dice-area {
            background-color: var(--medium-dark); 
            border-color: #4B5563;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3);
            color: var(--light-text);
        }
        #hand-result-display {
            color: var(--highlight-green); 
            text-shadow: none;
        }
        
        /* DICE STYLES */
        .dice {
            width: 50px; 
            height: 50px;
            background-color: var(--dark-container); 
            border: 2px solid #6B7280; 
            border-radius: 10px; 
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5); 
            padding: 5px; 
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 36px; 
            line-height: 1; 
            color: white; 
        }
        .dice-held {
            transform: translateY(-5px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.7);
            border-color: var(--primary-red); 
            background-color: var(--medium-dark); 
        }
        .board-cell {
            background-color: #2D3748; 
            color: #F9FAFB; 
            border: 1px solid #4B5563; 
            transition: background-color 0.15s, transform 0.1s;
            user-select: none;
            overflow: hidden; 
            font-weight: 600; 
            font-shadow: none;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 2px;
            cursor: pointer;
            height: 100%;
            width: 100%;
        }
        /* Style for the text/word icons inside the cell (e.g., Straight, FREE) */
        .board-cell span {
            /* Reduced size for words like "Straight" to ensure fit */
            font-size: 0.75rem; 
            line-height: 1;
            display: flex; 
            align-items: center; 
            justify-content: center;
        }
        
        /* Specific CSS Grid for containing the dice symbols */
        .dice-container-in-cell {
            display: grid;
            grid-template-columns: repeat(2, 1fr); 
            grid-gap: 1px; 
            width: 100%;
            height: 100%;
            align-items: center;
            justify-items: center;
        }
        
        /* Style the actual emoji dice small inside the cell */
        .board-cell .dice-emoji {
            font-size: 1.1rem; 
            line-height: 1;
            padding: 0;
            margin: 0;
            display: block; 
            text-align: center;
            color: var(--light-text);
        }
        /* Ensure the words in special cells are large enough */
        .board-cell span:not(.dice-container-in-cell) {
            font-size: 0.75rem; /* Reduced size for words */
        }

        /* Specific style for the house emoji (Fullhouse) to make it stand out */
        .board-cell .house-emoji {
            font-size: 1.8rem; /* Make it large and prominent */
            line-height: 1;
        }


        .board-cell:hover:not(.claimed) {
            transform: scale(1.02);
            background-color: #4B5563; 
        }
        
        /* Highlight Class */
        .claimable {
            border: 3px solid var(--highlight-green); 
            box-shadow: 0 0 10px var(--highlight-green);
            animation: pulse-border 1.5s infinite alternate;
        }
        @keyframes pulse-border {
            from { box-shadow: 0 0 8px rgba(16, 185, 129, 0.8); }
            to { box-shadow: 0 0 15px rgba(16, 185, 129, 1.0); }
        }

        .player-chip {
            width: 80%;
            height: 80%;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white; 
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5); 
            font-size: 1.25rem;
        }
        /* Player colors */
        .player-1 { 
            background-color: var(--primary-blue); /* Blue */
            box-shadow: none;
            color: white;
        } 
        .player-2 { 
            background-color: var(--primary-red); /* Red */
            box-shadow: none;
            color: white;
        }
        .player-3 {
            background-color: var(--primary-green); /* Green */
            box-shadow: none;
            color: white;
        }
        
        /* Sequence markers to show chips are part of a winning line */
        .in-sequence {
            border: 2px solid #FFD700; /* Gold border */
            box-shadow: 0 0 5px #FFD700;
        }

        .control-button {
            transition: background-color 0.15s, transform 0.1s;
            box-shadow: 0 4px #101620; 
            color: white;
            text-shadow: none;
        }
        .control-button:active {
            transform: scale(0.98) translateY(2px);
            box-shadow: 0 2px #101620;
        }
        
        /* Roll Button styles are managed entirely by JS using Tailwind utility classes */
        
        #next-turn-button {
            background-color: var(--medium-dark); 
        }
        #next-turn-button:hover {
            background-color: #4B5563; 
        }
        #restart-button {
             background-color: #DC2626; /* Red */
             color: white;
        }
        #restart-button:hover {
             background-color: #B91C1C;
        }
        #stats-button {
             background-color: #FBBF24; /* Yellow */
             color: #1F2937; /* Dark text */
        }
        #stats-button:hover {
             background-color: #F59E0B;
        }
        
        /* Modal Content Styling (Applied to all modal content) */
        .modal-content {
             background-color: var(--dark-container); 
             color: var(--light-text);
             box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
             border-radius: 0.75rem;
             padding: 2rem;
             width: 100%;
             max-width: 400px; /* Default max width */
             /* FIX: Ensure content inside modal wrapper is centered vertically */
             display: flex;
             flex-direction: column;
             justify-content: center;
        }
        
        /* Specific max-width for the Stats Modal */
        #stats-modal .modal-content {
            max-width: 600px;
        }

        /* Mobile adjustments */
        @media (max-width: 640px) {
            .board-cell {
                padding: 1px;
            }
            .dice {
                width: 40px;
                height: 40px;
                font-size: 28px;
            }
            /* Adjust dice size on the board for small screens */
            .board-cell .dice-emoji {
                font-size: 1rem; 
            }
            .board-cell .house-emoji {
                font-size: 1.6rem; 
            }
        }
    </style>
</head>
<body class="p-4 min-h-screen">

    <div id="game-container" class="max-w-4xl mx-auto shadow-2xl rounded-xl p-6">
        
        <!-- COMPACT HEADER (TITLE) -->
        <div class="text-center mb-4">
             <h1 class="text-2xl font-black pb-1">Dice Poker Sequence (<span id="win-goal-text">2 Runs to Win</span>)</h1>
        </div>

        <!-- Dice Area (ABOVE THE BOARD) -->
        <div id="dice-area" class="flex justify-center space-x-3 mt-0 mb-4 p-4 border rounded-lg shadow">
            <!-- Dice elements will be inserted here -->
        </div>
        
        <!-- Game Board -->
        <div id="game-board-container" class="aspect-square w-full max-w-lg mx-auto border-4 border-gray-800 rounded-lg overflow-hidden shadow-2xl mb-6 bg-gray-800">
            <div id="game-board" class="grid grid-cols-9 grid-rows-9 h-full w-full">
                <!-- Board cells will be inserted here -->
            </div>
        </div>
        
        <!-- --- CONTROLS (Between Board and Status) --- -->
        
        <!-- Primary Controls (Roll & End Turn) -->
        <div class="flex justify-center space-x-4 mt-8 mb-4">
            <button id="roll-button" class="control-button text-white font-bold py-3 px-8 rounded-lg shadow-md text-lg transition duration-150 ease-in-out" disabled>
                Roll Dice (3 Left)
            </button>
            <button id="next-turn-button" class="control-button bg-medium-dark text-white font-bold py-3 px-8 rounded-lg shadow-md text-lg transition duration-150 ease-in-out" disabled>
                End Turn
            </button>
        </div>
        
        <!-- Secondary Controls (Stats & Restart) -->
        <div class="flex justify-center space-x-4 mt-4 mb-4">
             <button id="stats-button" class="control-button bg-yellow-500 hover:bg-yellow-600 text-gray-800 font-bold py-2 px-6 rounded-lg shadow-md text-base transition duration-150 ease-in-out">
                View Stats
            </button>
            <button id="restart-button" class="control-button bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-6 rounded-lg shadow-md text-base transition duration-150 ease-in-out">
                Restart Game
            </button>
        </div>
        
        <!-- Game Info & Status (Minimized) - MOVED TO BE LAST -->
        <div id="status-panel" class="mb-4 p-3 rounded-lg shadow-inner">
            <!-- Row 1: Turn, Rolls, and Hand Result -->
            <div class="flex justify-between items-center mb-2">
                <div id="current-turn-display" class="text-base font-semibold"></div>
                <div id="rolls-left-display" class="text-sm text-gray-400"></div>
            </div>
            <div id="hand-result-display" class="text-xl font-extrabold text-center mt-1"></div>

            <!-- Row 2: Player Win Count -->
            <div id="win-count-display" class="text-sm text-center font-semibold mt-2 border-t border-gray-600 pt-2"></div>
        </div>
        
        <!-- --- END NEW LAYOUT --- -->
        
        <!-- Game Message/Modal (Used for General Messages and Confirmation Prompts) -->
        <div id="message-box" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center p-4 z-50">
            <!-- Modal Content Wrapper for Centering -->
            <div class="modal-content text-center">
                <h3 id="message-title" class="text-2xl font-bold mb-4 text-gray-100"></h3>
                <p id="message-text" class="text-lg mb-6"></p>
                <!-- Button text changes based on context (winner, error, or restart confirmation) -->
                <button id="dismiss-button" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-6 rounded-lg shadow-md">
                    OK / New Game
                </button>
                <button id="cancel-button" class="hidden bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg shadow-md ml-4">
                    Cancel
                </button>
            </div>
        </div>
        
        <!-- Statistics Modal -->
        <div id="stats-modal" class="fixed inset-0 bg-black bg-opacity-75 hidden items-center justify-center p-4 z-50">
            <!-- Modal Content Wrapper for Centering -->
            <div class="modal-content !max-w-lg">
                <h3 class="text-3xl font-bold mb-4 text-gray-100">Game Statistics</h3>
                <div id="stats-content" class="text-left space-y-3 p-4 bg-gray-800 rounded-lg">
                    <!-- Stats loaded here -->
                </div>
                <button onclick="document.getElementById('stats-modal').classList.add('hidden')" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg shadow-md mt-6">
                    Close
                </button>
            </div>
        </div>

        <!-- Player Setup Modal (Hidden by default) -->
        <div id="setup-modal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-50">
            <div class="modal-content text-center">
                <h3 class="text-2xl font-bold mb-6 text-gray-100">Select Number of Players</h3>
                <div class="flex justify-center space-x-4">
                    <button id="start-2p" onclick="startGame(2)" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg shadow-lg">
                        2 Players
                    </button>
                    <button id="start-3p" onclick="startGame(3)" class="bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-lg shadow-lg">
                        3 Players
                    </button>
                </div>
            </div>
        </div>

        <!-- Continue Game Modal (Hidden by default) -->
        <div id="continue-modal" class="fixed inset-0 bg-black bg-opacity-75 hidden items-center justify-center p-4 z-50">
            <div class="modal-content text-center">
                <h3 class="text-2xl font-bold mb-4 text-gray-100">Saved Game Found</h3>
                <p class="text-lg mb-6">Do you want to continue your previous game?</p>
                <div class="flex justify-center space-x-4">
                    <button id="continue-saved-game" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg shadow-lg">
                        Continue
                    </button>
                    <button id="start-new-game" class="bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-lg shadow-lg">
                        Start New
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- CORE GAME LOGIC FUNCTIONS (Hoisted for safe event listener attachment) ---

        let pendingRestart = false; // State to track if the modal is a restart prompt
        
        function handleRoll() {
            if (rollsLeft > 0) {
                // Increment stats
                gameStats.totalRolls++;
                gameStats.rollsByPlayer[currentPlayer]++;

                for (let i = 0; i < 5; i++) {
                    if (!diceHeld[i]) {
                        diceValues[i] = Math.floor(Math.random() * 6) + 1;
                    }
                }
                rollsLeft--;
                checkHand();
                renderDice();
                updateStatus();
                highlightClaimableSpaces(); 

                ROLL_BUTTON.disabled = true;
                setTimeout(() => {
                    ROLL_BUTTON.disabled = rollsLeft === 0;
                    NEXT_TURN_BUTTON.disabled = !(currentHandMatch === HAND_KEYS.BUST || rollsLeft === 0);
                }, 500);
                saveGame(); // AUTOSAVE after roll
            }
        }
        
        function endTurn() {
            currentPlayer = currentPlayer === numPlayers ? 1 : currentPlayer + 1;
            rollsLeft = 3;
            diceHeld = [false, false, false, false, false];
            currentHandMatch = null;
            
            ROLL_BUTTON.disabled = false;
            NEXT_TURN_BUTTON.disabled = true;
            
            renderBoard();
            renderDice();
            updateStatus();
            saveGame(); // AUTOSAVE after turn ends
        }

        function dismissMessage() {
            MESSAGE_BOX.classList.add('hidden');
            
            // Only perform game-ending actions if the state flag is set
            if (gameWon) {
                clearSave(); 
            } else if (pendingRestart) {
                // This branch should only be hit if the user clicked "OK" after an error, 
                // but the Restart confirmation logic has separate handlers (handleRestartConfirmation).
                // Do nothing here for restart cleanup, as it's handled by handleRestartCancel.
            }
            // Hide cancel button if it was shown (cleanup)
            document.getElementById('cancel-button').classList.add('hidden');
            pendingRestart = false;
        }
        
        function handleRestartConfirmation() {
            // This function is bound to the OK button when pendingRestart is true or after a win
            clearSave();
            document.getElementById('cancel-button').classList.add('hidden');
            MESSAGE_BOX.classList.add('hidden');
            pendingRestart = false;
            
            // --- FIX 2: Correct Restart Flow ---
            // Instead of calling initGame(), which re-checks for saved state, 
            // we skip directly to the player selection modal.
            document.getElementById('setup-modal').classList.remove('hidden');
        }
        
        function handleRestartCancel() {
             // This function is bound to the Cancel button during restart prompt
            document.getElementById('cancel-button').classList.add('hidden');
            MESSAGE_BOX.classList.add('hidden');
            pendingRestart = false;
            // Restore original button text
            DISMISS_BUTTON.textContent = 'OK / New Game';
            // Detach restart confirmation handler and re-attach normal dismiss
            DISMISS_BUTTON.removeEventListener('click', handleRestartConfirmation);
            DISMISS_BUTTON.addEventListener('click', dismissMessage);
        }

        function promptRestartConfirmation() {
            // Show confirmation modal
            showMessage("Confirm Restart", "Are you sure you want to quit the current game and start over? All progress will be lost.", false, true);
        }

        function showMessage(title, text, isWinner = false, isRestart = false) {
            document.getElementById('message-title').textContent = title;
            document.getElementById('message-text').textContent = text;
            MESSAGE_BOX.classList.remove('hidden');
            gameWon = isWinner; 
            pendingRestart = isRestart;

            const cancelButton = document.getElementById('cancel-button');
            
            // Cleanup: remove all prior handlers
            DISMISS_BUTTON.removeEventListener('click', dismissMessage);
            DISMISS_BUTTON.removeEventListener('click', handleRestartConfirmation);
            cancelButton.removeEventListener('click', handleRestartCancel);

            if (isRestart) {
                // Setup for Restart Confirmation
                DISMISS_BUTTON.textContent = 'Yes, Restart';
                DISMISS_BUTTON.addEventListener('click', handleRestartConfirmation);
                
                cancelButton.classList.remove('hidden');
                cancelButton.addEventListener('click', handleRestartCancel);
            } else if (isWinner) {
                // Setup for Winner Message
                DISMISS_BUTTON.textContent = 'Start New Game';
                DISMISS_BUTTON.addEventListener('click', handleRestartConfirmation); // Winner always leads to restart
                cancelButton.classList.add('hidden');
            } else {
                // Setup for Generic Message (e.g., Invalid Claim, BUST)
                DISMISS_BUTTON.textContent = 'OK';
                DISMISS_BUTTON.addEventListener('click', dismissMessage);
                cancelButton.classList.add('hidden');
            }
        }

        function closeModalsOnClickOutside(event) {
            const modalId = event.currentTarget.id;
            const modalEl = event.currentTarget;
            const modalContent = modalEl.querySelector('.modal-content');

            if (event.target === modalEl && modalContent && !modalContent.contains(event.target)) {
                 if (modalId === 'stats-modal') {
                     STATS_MODAL.classList.add('hidden');
                 } else if (modalId === 'message-box' && !gameWon && !pendingRestart) {
                     // Only close message box if it's not a winner/restart state
                     MESSAGE_BOX.classList.add('hidden');
                 }
            }
        }

        function toggleDiceHold(index) {
            if (rollsLeft < 3) {
                diceHeld[index] = !diceHeld[index];
                renderDice();
            }
        }

        // --- CONSTANTS AND STATE ---

        const SAVE_KEY = 'dicePokerSequenceSave';
        const BOARD_DATA = [
            ["Straight", "6 6 6 6", "6 6 5 5", "6 6 4 4", "1 1", "6 6 3 3", "6 6 2 2", "6 6 1 1", "Straight"],
            ["6 6", "Fullhouse", "5 5 1 1", "5 5 2 2", "5 5 3 3", "5 5 4 4", "5 5 5 5", "Fullhouse", "4 4"],
            ["4 4 4 4", "2 2 2", "Fullhouse", "4 4 3 3", "1 1 1 1", "4 4 2 2", "Fullhouse", "6 6 6", "4 4 1 1"],
            ["4 4 4", "1 1 1", "3 3 3 3", "Fullhouse", "3 3 2 2", "Fullhouse", "3 3 1", "3 3 3", "5 5 5"],
            ["Lucky 7", "1 1 2 2", "Lucky 11", "2 2 2 2", "FREE", "Lucky 11", "2 2 2 2", "1 1 2 2", "Lucky 7"],
            ["5 5 5", "3 3 3", "1 3 3", "Fullhouse", "2 2 3 3", "Fullhouse", "3 3 3 3", "1 1 1", "4 4 4"],
            ["1 1 4 4", "6 6 6", "Fullhouse", "2 2 4 4", "1 1 1 1", "3 3 4 4", "Fullhouse", "2 2 2", "4 4 4 4"],
            ["4 4", "Fullhouse", "5 5 5 5", "4 4 5 5", "3 3 5 5", "2 2 5 5", "1 1 5 5", "Fullhouse", "6 6"],
            ["Straight", "1 1 6 6", "2 2 6 6", "3 3 6 6", "2 2", "4 4 6 6", "5 5 6 6", "6 6 6 6", "Straight"] 
        ];

        const HAND_KEYS = {
            'Straight': 'Straight', 'Fullhouse': 'Fullhouse', 'Lucky 7': 'Lucky 7', 'Lucky 11': 'Lucky 11',
            'BUST': 'BUST', 'FREE': 'FREE'
        };
        const WIN_GOAL = 2;
        const playerNames = { 1: 'Blue', 2: 'Red', 3: 'Green' }; 
        
        let boardState = [];
        let diceValues = [1, 1, 1, 1, 1];
        let diceHeld = [false, false, false, false, false];
        let currentPlayer = 1;
        let rollsLeft = 3;
        let currentHandMatch = null;
        let gameWon = false; 
        let numPlayers = 3; 
        let playerSequences = { 1: 0, 2: 0, 3: 0 };
        let gameStats = {}; 
        
        // DOM element variables
        let STATUS_DISPLAY, TURN_DISPLAY, ROLLS_DISPLAY, HAND_RESULT_DISPLAY, ROLL_BUTTON, NEXT_TURN_BUTTON, WIN_COUNT_DISPLAY, WIN_GOAL_TEXT, DISMISS_BUTTON, STATS_MODAL, MESSAGE_BOX, CONTINUE_MODAL;

        // --- AUTOSAVE/LOAD LOGIC ---
        function saveGame() {
            const data = {
                boardState: boardState,
                diceValues: diceValues,
                diceHeld: diceHeld,
                currentPlayer: currentPlayer,
                rollsLeft: rollsLeft,
                currentHandMatch: currentHandMatch,
                gameWon: gameWon,
                numPlayers: numPlayers,
                playerSequences: playerSequences,
                gameStats: gameStats
            };
            localStorage.setItem(SAVE_KEY, JSON.stringify(data));
        }

        function loadGame() {
            const savedData = localStorage.getItem(SAVE_KEY);
            if (!savedData) return false;
            
            try {
                const data = JSON.parse(savedData);
                
                // Restore state from saved data
                boardState = data.boardState;
                diceValues = data.diceValues;
                diceHeld = data.diceHeld;
                currentPlayer = data.currentPlayer;
                rollsLeft = data.rollsLeft;
                currentHandMatch = data.currentHandMatch;
                gameWon = data.gameWon;
                numPlayers = data.numPlayers;
                playerSequences = data.playerSequences;
                gameStats = data.gameStats;
                
                // Data sanity check
                if (!boardState || boardState.length !== 9) return false;

                return true;
            } catch (e) {
                console.error("Error loading game state:", e);
                localStorage.removeItem(SAVE_KEY); // Clear corrupted save
                return false;
            }
        }
        
        function clearSave() {
            localStorage.removeItem(SAVE_KEY);
        }

        // --- UTILITY FUNCTIONS ---

        function getDiceDots(value) {
             // Use Unicode dice characters for better mobile scaling and rendering consistency
            const unicodeDice = ['\u2680', '\u2681', '\u2682', '\u2683', '\u2684', '\u2685'];
            // value 1 corresponds to index 0, value 6 corresponds to index 5
            return unicodeDice[value - 1];
        }
        
        function renderBoardHand(handString) {
             // Special text strings that should not be converted
            if (handString === HAND_KEYS.Fullhouse) {
                 // **CHANGE: Use the House Emoji**
                 return `<span class="house-emoji">üè°</span>`;
            }
            if (['Lucky 7', 'Lucky 11', 'FREE'].includes(handString)) {
                // Return text wrapped in a span without the specific dice-container for special hands
                return `<span>${handString}</span>`;
            }
            
            // Special case for 'Straight' to apply the smaller font size explicitly
            if (handString === HAND_KEYS.Straight) {
                // Return text wrapped in a span with a custom class for small font
                return `<span class="text-xs font-semibold">${handString}</span>`;
            }

            // For strings of numbers (e.g., "6 6 5 5" or "4 4 4"), convert to dice emojis
            const parts = handString.split(' ').filter(p => p.length > 0);
            
            let html = '';
            
            // Create a small, compact group of dice emojis, letting CSS handle the grid wrap
            for (let i = 0; i < parts.length; i++) {
                const value = parseInt(parts[i]);
                if (!isNaN(value) && value >= 1 && value <= 6) {
                    // Each emoji is wrapped in a span with dice-emoji class for specific styling
                    html += `<span class="dice-emoji">${getDiceDots(value)}</span>`;
                }
            }
            
            // Wrap the emojis in a specific container to trigger the CSS Grid layout
            return `<div class="dice-container-in-cell">${html}</div>`;
        }

        function getHandString(values, type) {
            if (type === '5K') return `${values[0]} ${values[0]} ${values[0]} ${values[0]} ${values[0]}`;
            if (type === '4K') {
                const four = values.find(v => values.filter(x => x === v).length === 4);
                return `${four} ${four} ${four} ${four}`;
            }
            if (type === '3K') {
                const three = values.find(v => values.filter(x => x === v).length === 3);
                return `${three} ${three} ${three}`;
            }
            if (type === '2P') {
                const counts = {};
                values.forEach(val => { counts[val] = (counts[val] || 0) + 1; });
                const pairs = Object.keys(counts).filter(k => counts[k] === 2).sort((a, b) => Number(b) - Number(a)); 
                return `${pairs[0]} ${pairs[0]} ${pairs[1]} ${pairs[1]}`; 
            }
            if (type === '1P') {
                const pair = values.find(v => values.filter(x => x === v).length === 2);
                return `${pair} ${pair}`;
            }
            return ''; 
        }
        
        function checkHand() {
            const counts = {};
            let sum = 0;
            diceValues.forEach(val => { counts[val] = (counts[val] || 0) + 1; sum += val; });
            const numUnique = Object.keys(counts).length;
            const values = Object.values(counts);

            if (sum === 7) { currentHandMatch = HAND_KEYS['Lucky 7']; return; }
            if (sum === 11) { currentHandMatch = HAND_KEYS['Lucky 11']; return; }

            let handType = null;
            if (values.includes(5)) { handType = '5K'; } 
            else if (values.includes(4)) { handType = '4K'; } 
            else if (values.includes(3) && values.includes(2)) { handType = 'FH'; } 
            else if (numUnique === 5) {
                const sorted = [...diceValues].sort((a, b) => a - b);
                const isStraight = sorted[4] - sorted[0] === 4;
                handType = isStraight ? 'Straight' : 'BUST';
            } 
            else if (values.includes(3)) { handType = '3K'; } 
            else if (values.includes(2) && numUnique === 3) { handType = '2P'; } 
            else if (values.includes(2) && numUnique === 4) { handType = '1P'; } 
            else { handType = 'BUST'; }

            if (handType === 'Straight') { currentHandMatch = HAND_KEYS.Straight; } 
            else if (handType === 'FH') { currentHandMatch = HAND_KEYS.Fullhouse; } 
            else if (handType === 'BUST') { currentHandMatch = HAND_KEYS.BUST; } 
            else if (['5K', '4K', '3K', '2P', '1P'].includes(handType)) {
                currentHandMatch = getHandString(diceValues, handType);
            } else {
                 currentHandMatch = HAND_KEYS.BUST; 
            }
        }
        
        // --- GAME FLOW HANDLERS ---

        function handleClaim(r, c) {
            if (!currentHandMatch || rollsLeft === 3) {
                showMessage("Roll First!", "You must roll the dice and have a valid hand before claiming a space.");
                return;
            }
            
            if (currentHandMatch === HAND_KEYS.BUST) {
                showMessage("BUST!", "A BUST hand cannot be used to claim any space. Please end your turn.");
                return;
            }

            const spaceHand = boardState[r][c].hand;
            let matched = (spaceHand === HAND_KEYS.FREE || spaceHand === currentHandMatch);
            
            if (matched) {
                gameStats.successfulClaims++;
                gameStats.claimsByPlayer[currentPlayer]++;
                
                boardState[r][c].owner = currentPlayer;
                
                const sequencesFound = findSequences(currentPlayer);
                const newSequenceCount = sequencesFound.length;
                
                if (newSequenceCount > playerSequences[currentPlayer]) {
                    boardState.forEach(row => row.forEach(cell => {
                        if (cell.owner === currentPlayer) cell.inSequence = false;
                    }));
                    
                    sequencesFound.forEach(seq => {
                        seq.cells.forEach(cellCoords => {
                            boardState[cellCoords.r][cellCoords.c].inSequence = true;
                        });
                    });

                    playerSequences[currentPlayer] = newSequenceCount;
                    
                    if (playerSequences[currentPlayer] >= WIN_GOAL) {
                        showMessage(`Game Over!`, `${playerNames[currentPlayer]} Wins by forming ${WIN_GOAL} sequences!`, true);
                        return;
                    }
                }
                
                endTurn();
            } else {
                showMessage("Invalid Claim", `Your current hand (${currentHandMatch || 'None'}) does not match the space: ${spaceHand}.`);
            }
        }
        
        // --- UI/RENDERING ---
        
        function renderBoard() {
            const boardEl = document.getElementById('game-board');
            boardEl.innerHTML = '';
            
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    const cell = boardState[r][c];
                    const cellEl = document.createElement('div');
                    cellEl.className = 'board-cell rounded';
                    cellEl.dataset.row = r;
                    cellEl.dataset.col = c;
                    cellEl.innerHTML = renderBoardHand(cell.hand);

                    if (cell.owner > 0) {
                        cellEl.classList.add('claimed');
                        const chipLabel = playerNames[cell.owner].charAt(0); 
                        cellEl.innerHTML = `<div class="player-chip player-${cell.owner}">${chipLabel}</div>`;
                        cellEl.onclick = null;
                        if (cell.inSequence) {
                            cellEl.classList.add('in-sequence'); 
                        } else {
                            cellEl.classList.remove('in-sequence');
                        }
                    } else {
                        cellEl.onclick = () => handleClaim(r, c);
                        cellEl.classList.remove('claimable', 'in-sequence'); 
                    }
                    boardEl.appendChild(cellEl);
                }
            }
        }
        
        function highlightClaimableSpaces() {
            document.querySelectorAll('.claimable').forEach(el => el.classList.remove('claimable'));
            if (!currentHandMatch || currentHandMatch === HAND_KEYS.BUST) return;

            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    const cell = boardState[r][c];
                    if (cell.owner === 0) { 
                        const spaceHand = cell.hand;
                        let matched = (spaceHand === HAND_KEYS.FREE || spaceHand === currentHandMatch);
                        
                        if (matched) {
                            const cellEl = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                            if (cellEl) {
                                cellEl.classList.add('claimable');
                            }
                        }
                    }
                }
            }
        }

        function renderDice() {
            const diceAreaEl = document.getElementById('dice-area');
            diceAreaEl.innerHTML = '';
            diceValues.forEach((value, index) => {
                const diceEl = document.createElement('div');
                // FIX: Remove 'bg-gray-200' so the dark background from the CSS (.dice) is used
                diceEl.className = `dice ${diceHeld[index] ? 'dice-held' : ''}`;
                // Use Unicode char
                diceEl.textContent = getDiceDots(value); 
                diceEl.onclick = () => toggleDiceHold(index);
                diceAreaEl.appendChild(diceEl);
            });
        }

        function updateStatus() {
            const name = playerNames[currentPlayer];
            const color = name;
            TURN_DISPLAY.textContent = `${name}'s Turn (${color} Chip)`;
            ROLLS_DISPLAY.textContent = `Rolls Remaining: ${rollsLeft}`;
            
            let winCountHtml = `Sequences: `;
            for(let i = 1; i <= numPlayers; i++) {
                 const colorClass = i === 1 ? 'text-blue-400' : (i === 2 ? 'text-red-400' : 'text-green-400');
                 winCountHtml += `<span class="${colorClass} mx-2">${playerNames[i]} (${playerSequences[i]})</span>`;
            }
            WIN_COUNT_DISPLAY.innerHTML = winCountHtml;

            if (currentHandMatch) {
                HAND_RESULT_DISPLAY.textContent = `Hand: ${currentHandMatch}`;
                HAND_RESULT_DISPLAY.classList.remove('text-red-700', 'text-green-700', 'text-yellow-700');
                if (currentHandMatch === HAND_KEYS.BUST) {
                    HAND_RESULT_DISPLAY.classList.add('text-red-700');
                } else if (currentHandMatch === HAND_KEYS['Lucky 7'] || currentHandMatch === HAND_KEYS['Lucky 11']) {
                     HAND_RESULT_DISPLAY.classList.add('text-yellow-700');
                } else {
                    HAND_RESULT_DISPLAY.classList.add('text-green-700');
                }
            } else if (rollsLeft === 3) {
                HAND_RESULT_DISPLAY.textContent = 'Roll to start!';
                HAND_RESULT_DISPLAY.classList.remove('text-red-700', 'text-green-700', 'text-yellow-700');
            } else {
                HAND_RESULT_DISPLAY.textContent = 'Hold dice and Roll again or End Turn.';
                HAND_RESULT_DISPLAY.classList.remove('text-red-700', 'text-green-700', 'text-yellow-700');
            }

            const rollButtonEl = document.getElementById('roll-button');
            const allColorClasses = [
                'bg-blue-600', 'hover:bg-blue-700', 'bg-red-600', 'hover:bg-red-700', 'bg-green-600', 'hover:bg-green-700'
            ];
            const playerColors = {
                1: ['bg-blue-600', 'hover:bg-blue-700'],
                2: ['bg-red-600', 'hover:bg-red-700'],
                3: ['bg-green-600', 'hover:bg-green-700']
            };

            rollButtonEl.classList.remove(...allColorClasses);

            if (playerColors[currentPlayer]) {
                rollButtonEl.classList.add(...playerColors[currentPlayer]);
            }
            ROLL_BUTTON.textContent = `Roll Dice (${rollsLeft} Left)`;
            if (rollsLeft === 0) {
                ROLL_BUTTON.disabled = true;
                ROLL_BUTTON.textContent = 'No Rolls Left';
            }
        }
        
        // --- STATS / SEQUENCE CHECKING ---
        
        function showStats() {
            const statsContentEl = document.getElementById('stats-content');
            let html = `
                <h4 class="text-xl font-semibold mb-2 text-gray-400">Overall Game</h4>
                <p class="pl-4">Total Dice Rolls: <strong>${gameStats.totalRolls}</strong></p>
                <p class="pl-4 mb-4">Total Successful Claims: <strong>${gameStats.successfulClaims}</strong></p>
                
                <h4 class="text-xl font-semibold mb-2 text-gray-400">Player Performance</h4>
                <ul class="space-y-3 pl-4">
            `;

            for (let i = 1; i <= numPlayers; i++) {
                const name = playerNames[i];
                const rolls = gameStats.rollsByPlayer[i];
                const claims = gameStats.claimsByPlayer[i];
                const sequences = playerSequences[i];
                const successRate = rolls > 0 ? ((claims / rolls) * 100).toFixed(1) : 0;
                
                html += `
                    <li class="p-3 border-l-4 ${i === 1 ? 'border-blue-500' : (i === 2 ? 'border-red-500' : 'border-green-500')} bg-gray-800 rounded shadow-sm">
                        <strong class="text-lg">${name} (P${i}):</strong>
                        <ul>
                            <li>- Sequences Achieved: <strong>${sequences} / ${WIN_GOAL}</strong></li>
                            <li>- Total Rolls: ${rolls}</li>
                            <li>- Successful Claims: ${claims}</li>
                            <li>- Claim Success Rate: ${successRate}%</li>
                        </ul>
                    </li>
                `;
            }
            html += `</ul>`;
            
            statsContentEl.innerHTML = html;
            STATS_MODAL.classList.remove('hidden');
        }

        function findSequences(player) {
            const sequencesFound = [];
            const N = 9;
            const WIN_LENGTH = 5;
            const directions = [[0, 1], [1, 0], [1, 1], [1, -1]]; 
            
            directions.forEach(([dr, dc]) => {
                for (let i = 0; i < N; i++) {
                    for (let j = 0; j < N; j++) {
                        let currentSeq = [];
                        
                        for (let k = 0; k < WIN_LENGTH; k++) {
                            const currR = i + k * dr;
                            const currC = j + k * dc;

                            if (currR < 0 || currR >= N || currC < 0 || currC >= N) {
                                currentSeq = [];
                                break;
                            }
                            
                            const cell = boardState[currR][currC];
                            if (cell.owner === player || cell.hand === HAND_KEYS.FREE) {
                                currentSeq.push({r: currR, c: currC}); 
                            } else {
                                currentSeq = [];
                                break;
                            }
                        }

                        if (currentSeq.length === WIN_LENGTH) {
                            const hash = currentSeq.map(cell => `${cell.r},${cell.c}`).sort().join('|');
                            if (!sequencesFound.some(seq => seq.hash === hash)) {
                                sequencesFound.push({ hash: hash, cells: currentSeq });
                            }
                        }
                    }
                }
            });
            
            return sequencesFound;
        }

        // --- GAME INITIALIZATION & SETUP ---

        function initGame() {
            // Initialize DOM element references now, before potentially showing modals
            STATUS_DISPLAY = document.getElementById('status-panel');
            TURN_DISPLAY = document.getElementById('current-turn-display');
            ROLLS_DISPLAY = document.getElementById('rolls-left-display');
            HAND_RESULT_DISPLAY = document.getElementById('hand-result-display');
            ROLL_BUTTON = document.getElementById('roll-button');
            NEXT_TURN_BUTTON = document.getElementById('next-turn-button');
            WIN_COUNT_DISPLAY = document.getElementById('win-count-display');
            WIN_GOAL_TEXT = document.getElementById('win-goal-text');
            DISMISS_BUTTON = document.getElementById('dismiss-button');
            STATS_MODAL = document.getElementById('stats-modal');
            MESSAGE_BOX = document.getElementById('message-box');
            CONTINUE_MODAL = document.getElementById('continue-modal');

            // Attach external modal handlers
            STATS_MODAL.addEventListener('click', closeModalsOnClickOutside);
            MESSAGE_BOX.addEventListener('click', closeModalsOnClickOutside);
            
            if (loadGame()) {
                 // Saved game found, show the continue prompt
                CONTINUE_MODAL.classList.remove('hidden');
                document.getElementById('continue-saved-game').onclick = () => {
                    CONTINUE_MODAL.classList.add('hidden');
                    runGameSetup(true); // Load saved game
                };
                
                // FIX 1: Clicking Start New Game when a save is found should skip directly to player selection
                document.getElementById('start-new-game').onclick = () => {
                    CONTINUE_MODAL.classList.add('hidden');
                    clearSave(); // Clear save file
                    document.getElementById('setup-modal').classList.remove('hidden'); // Show player count selection
                };
            } else {
                 // No saved game, show player count selection
                document.getElementById('setup-modal').classList.remove('hidden');
            }
        }
        
        function startGame(count) {
            numPlayers = count;
            document.getElementById('setup-modal').classList.add('hidden');
            runGameSetup(false); // Start new game
        }
        
        function runGameSetup(isLoad = false) {
            // DOM elements already initialized in initGame now.
            const CANCEL_BUTTON = document.getElementById('cancel-button'); 

            // --- EVENT LISTENERS ---
            ROLL_BUTTON.removeEventListener('click', handleRoll);
            NEXT_TURN_BUTTON.removeEventListener('click', endTurn);
            DISMISS_BUTTON.removeEventListener('click', dismissMessage);
            CANCEL_BUTTON.removeEventListener('click', handleRestartCancel); // Ensure cancel button is bound correctly for safety
            
            ROLL_BUTTON.addEventListener('click', handleRoll);
            NEXT_TURN_BUTTON.addEventListener('click', endTurn);
            DISMISS_BUTTON.addEventListener('click', dismissMessage);
            CANCEL_BUTTON.addEventListener('click', handleRestartCancel); // Attach specific cancel handler

            document.getElementById('restart-button').addEventListener('click', promptRestartConfirmation);
            document.getElementById('stats-button').addEventListener('click', showStats);
            
            if (!isLoad) {
                // Initialize NEW board state and stats
                for (let r = 0; r < 9; r++) {
                    boardState[r] = [];
                    for (let c = 0; c < 9; c++) {
                        boardState[r][c] = {
                            owner: 0, hand: BOARD_DATA[r][c].trim(), inSequence: false
                        };
                    }
                }
                currentPlayer = 1;
                rollsLeft = 3;
                diceHeld = [false, false, false, false, false];
                currentHandMatch = null;
                gameWon = false; 
                playerSequences = {};
                gameStats = { totalRolls: 0, successfulClaims: 0, rollsByPlayer: {}, claimsByPlayer: {} };

                for (let i = 1; i <= numPlayers; i++) {
                    playerSequences[i] = 0;
                    gameStats.rollsByPlayer[i] = 0;
                    gameStats.claimsByPlayer[i] = 0;
                }
                clearSave(); // Ensure a clean start wipes the old save
            } else {
                 // Game loaded successfully, render the saved state
                 
                 // Re-attach inSequence flags based on current state (needed because sequences are transient)
                 const sequencesFound = findSequences(currentPlayer);
                 sequencesFound.forEach(seq => {
                    seq.cells.forEach(cellCoords => {
                        // FIX: Ensure correct indexing for state update
                        boardState[cellCoords.r][cellCoords.c].inSequence = true; 
                    });
                });
            }

            WIN_GOAL_TEXT.textContent = `${WIN_GOAL} Runs to Win`;
            renderBoard();
            renderDice();
            updateStatus();
            ROLL_BUTTON.disabled = false;
            NEXT_TURN_BUTTON.disabled = true;
            MESSAGE_BOX.classList.add('hidden');
            CONTINUE_MODAL.classList.add('hidden');
        }
        
        window.onload = initGame;
    </script>
</body>
</html>
